package com.dqc.puppymoney.ui.viewimport android.animation.Animatorimport android.animation.AnimatorListenerAdapterimport android.animation.ValueAnimatorimport android.content.Contextimport android.graphics.Canvasimport android.graphics.Paintimport android.os.Handlerimport android.os.Messageimport android.os.SystemClockimport android.util.AttributeSetimport android.util.Logimport android.view.MotionEventimport android.view.Viewimport android.view.animation.DecelerateInterpolatorimport com.dqc.puppymoney.util.dp2pxclass WaterWaveView(context: Context?, attrs: AttributeSet?) : View(context, attrs) {    private var mDifferMills = 4000 / 3L    private var mCenterX = 0f    private var mCenterY = 0f    private var mWaveValue = 0f    private var mWaveValue1 = 0f    private var mWaveValue2 = 0f    private var mWaveAnim: ValueAnimator? = null    private var mWaveAnim1: ValueAnimator? = null    private var mWaveAnim2: ValueAnimator? = null    private var mIsStartAnim = false    private var mIsStartAnim1 = false    private var mIsStartAnim2 = false    private var mIsNeedCancleAnim = false    private var mRadius = 0f    private var mMaxRadius = 0f    private var mStartMills = 0L    private var mIsPause = false    private var mStopWave = false    private var mStopWave1 = false    private var mStopWave2 = false    private var mNeedInitAnim: Boolean = false    private var mTempLastAnimIndex = 0    private var mA = false    private var mWavePaint = Paint().apply {        isDither = true        isAntiAlias = true        style = Paint.Style.STROKE        strokeWidth = dp2px(2).toFloat()        color = 0x4Cffffff    }    private var mWavePaint1 = Paint().apply {        isDither = true        isAntiAlias = true        style = Paint.Style.STROKE        strokeWidth = dp2px(2).toFloat()        color = 0x4Cffffff    }    private var mWavePaint2 = Paint().apply {        isDither = true        isAntiAlias = true        style = Paint.Style.STROKE        strokeWidth = dp2px(2).toFloat()        color = 0x4Cffffff    }    private var mHandler: Handler = object :Handler() {        override fun handleMessage(msg: Message) {            super.handleMessage(msg)            sendEmptyMessageDelayed(100, mDifferMills)        }    }    init {        mStartMills = SystemClock.elapsedRealtime()        initWaterWaveAnimator()        initWaterWaveAnimator1()        initWaterWaveAnimator2()        mHandler.sendEmptyMessage(100)    }    private fun controlStartAnim() {        mTempLastAnimIndex ++        if (mTempLastAnimIndex > 2) {            mTempLastAnimIndex = 0        }        Log.d("controlStartAnim", " controlStartAnim " + mTempLastAnimIndex)        startIndexAnim(mTempLastAnimIndex)    }    private fun startIndexAnim(index: Int) {        if (index == 0) {            waterWaveAnimator()        } else if (index == 1) {            waterWaveAnimator1()        } else if (index == 2) {            waterWaveAnimator2()        }    }    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {        super.onSizeChanged(w, h, oldw, oldh)        mCenterX = w / 2f        mCenterY = h / 2f        if (w < h) {            mRadius = mCenterX / 2            mMaxRadius = mCenterX        } else {            mRadius = mCenterY / 2            mMaxRadius = mCenterY        }    }    override fun onDraw(canvas: Canvas?) {        super.onDraw(canvas)        drawWaterWave(canvas)        invalidate()    }    private fun pauseWaterWaveAnim() {        mIsPause = true        Log.d("Pause", "1" + mIsPause)    }    private fun startWaterWaveAnim() {        mStartMills = SystemClock.elapsedRealtime()        mIsPause = false        mIsStartAnim = false        mIsStartAnim1 = false        mIsStartAnim2 = false    }    private fun drawWaterWave(canvas: Canvas?) {        if (mWaveValue > 0.01f) {            mWavePaint.alpha = (255 * (1 - mWaveValue)).toInt()            canvas?.drawCircle(mCenterX, mCenterY, mRadius + (mMaxRadius - mRadius) * mWaveValue, mWavePaint)        }        if (mWaveValue1 > 0.01f) {            mWavePaint1.alpha = (255 * (1 - mWaveValue1)).toInt()            canvas?.drawCircle(mCenterX, mCenterY, mRadius + (mMaxRadius - mRadius) * mWaveValue1, mWavePaint1)        }        if (mWaveValue2 > 0.01f) {            mWavePaint2.alpha = (255 * (1 - mWaveValue2)).toInt()            canvas?.drawCircle(mCenterX, mCenterY, mRadius + (mMaxRadius - mRadius) * mWaveValue2, mWavePaint2)        }    }    private fun initWaterWaveAnimator() {        mWaveAnim = ValueAnimator.ofFloat(1f)        mWaveAnim?.repeatCount = ValueAnimator.INFINITE        mWaveAnim?.interpolator = DecelerateInterpolator()        mWaveAnim?.setDuration(5 * 1000)        mWaveAnim?.addUpdateListener {            mWaveValue = it.animatedValue as Float        }        mWaveAnim?.addListener(object :AnimatorListenerAdapter() {            override fun onAnimationRepeat(animation: Animator?) {                super.onAnimationRepeat(animation)                if (mIsPause) {                    mWaveAnim?.cancel()                    mStopWave = true                    Log.d("a0", " cancle")                }            }            override fun onAnimationStart(animation: Animator?) {                super.onAnimationStart(animation)                Log.d("initWaveAnim1", " onStart")            }            override fun onAnimationEnd(animation: Animator?) {                super.onAnimationEnd(animation)                Log.d("a0", " onAnimationEnd")            }        })    }    private fun initWaterWaveAnimator1() {        mWaveAnim1 = ValueAnimator.ofFloat(1f)        mWaveAnim1?.repeatCount = ValueAnimator.INFINITE        mWaveAnim1?.interpolator = DecelerateInterpolator()        mWaveAnim1?.setDuration(5 * 1000)        mWaveAnim1?.addUpdateListener {            mWaveValue1 = it.animatedValue as Float        }        mWaveAnim1?.addListener(object :AnimatorListenerAdapter() {            override fun onAnimationRepeat(animation: Animator?) {                super.onAnimationRepeat(animation)                if (mIsPause) {                    mWaveAnim1?.cancel()                    mStopWave1 = true                }            }            override fun onAnimationStart(animation: Animator?) {                super.onAnimationStart(animation)                Log.d("initWaveAnim3", " onStart")            }            override fun onAnimationEnd(animation: Animator?) {                super.onAnimationEnd(animation)                Log.d("a1", " onAnimationEnd")            }        })    }    private fun initWaterWaveAnimator2() {        mWaveAnim2 = ValueAnimator.ofFloat(1f)        mWaveAnim2?.repeatCount = ValueAnimator.INFINITE        mWaveAnim2?.interpolator = DecelerateInterpolator()        mWaveAnim2?.setDuration(5 * 1000)        mWaveAnim2?.addUpdateListener {            mWaveValue2 = it.animatedValue as Float        }        mWaveAnim2?.addListener(object :AnimatorListenerAdapter() {            override fun onAnimationRepeat(animation: Animator?) {                super.onAnimationRepeat(animation)                if (mIsPause) {                    mWaveAnim2?.cancel()                    mStopWave2 = true                    Log.d("a2", " cancle")                }            }            override fun onAnimationStart(animation: Animator?) {                super.onAnimationStart(animation)                Log.d("initWaveAnim2", " onStart")            }            override fun onAnimationEnd(animation: Animator?) {                super.onAnimationEnd(animation)                Log.d("a2", " End2")            }        })    }    private fun waterWaveAnimator() {        if (mWaveAnim != null && !mWaveAnim!!.isStarted) {            mWaveAnim?.start()        } else if (mWaveAnim != null && mWaveAnim!!.isStarted) {            mWaveAnim?.resume()        }    }    private fun waterWaveAnimator1() {        if (mWaveAnim1 != null && !mWaveAnim1!!.isStarted) {            mWaveAnim1?.start()        } else if (mWaveAnim1 != null && mWaveAnim1!!.isStarted) {            mWaveAnim1?.resume()        }    }    private fun waterWaveAnimator2() {        if (mWaveAnim2 != null && !mWaveAnim2!!.isStarted) {            mWaveAnim2?.start()        } else if (mWaveAnim2 != null && mWaveAnim2!!.isStarted) {            mWaveAnim2?.resume()        }    }    override fun onTouchEvent(event: MotionEvent?): Boolean {        if (event?.action == MotionEvent.ACTION_DOWN) {            if (!mA) {                pauseWaterWaveAnim()            } else {                startWaterWaveAnim()            }            mA = !mA        }        return true    }}