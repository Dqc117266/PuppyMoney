package com.dqc.puppymoney.ui.viewimport android.animation.Animatorimport android.animation.AnimatorListenerAdapterimport android.animation.ValueAnimatorimport android.content.Contextimport android.graphics.Canvasimport android.graphics.Paintimport android.os.SystemClockimport android.util.AttributeSetimport android.util.Logimport android.view.MotionEventimport android.view.Viewimport android.view.animation.DecelerateInterpolatorimport com.dqc.puppymoney.util.dp2pxclass WaterWaveView3(context: Context?, attrs: AttributeSet?) : View(context, attrs) {    private var mDifferMills = 5000 / 3L    private var mCenterX = 0f    private var mCenterY = 0f    private var mWaveValue = 0f    private var mWaveValue1 = 0f    private var mWaveValue2 = 0f    private var mWaveAnim: ValueAnimator? = null    private var mWaveAnim1: ValueAnimator? = null    private var mWaveAnim2: ValueAnimator? = null    private var mIsStartAnim = false    private var mIsStartAnim1 = false    private var mIsStartAnim2 = false    private var mRadius = 0f    private var mMaxRadius = 0f    private var mStartMills = 0L    private var mPressPauseMills = 0L    private var mIsPause = false    private var mLastAimIndex = -1    private var mTempLastAnimIndex = -1    private var mIsPauseAfterStart = false    private var mLastAnimDurating = 0    private var mA = false    private var mWavePaint = Paint().apply {        isDither = true        isAntiAlias = true        style = Paint.Style.STROKE        strokeWidth = dp2px(2).toFloat()        color = 0x7fffffff    }    private var mWavePaint1 = Paint().apply {        isDither = true        isAntiAlias = true        style = Paint.Style.STROKE        strokeWidth = dp2px(2).toFloat()        color = 0x7fffffff    }    private var mWavePaint2 = Paint().apply {        isDither = true        isAntiAlias = true        style = Paint.Style.STROKE        strokeWidth = dp2px(2).toFloat()        color = 0x7fffffff    }    init {        mStartMills = SystemClock.elapsedRealtime()        initWaterWaveAnimator()        initWaterWaveAnimator1()        initWaterWaveAnimator2()        startWaterWaveAnim()    }    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {        super.onSizeChanged(w, h, oldw, oldh)        mCenterX = w / 2f        mCenterY = h / 2f        if (w < h) {            mRadius = mCenterX * 0.6f            mMaxRadius = mCenterX        } else {            mRadius = mCenterY * 0.6f            mMaxRadius = mCenterY        }    }    override fun onDraw(canvas: Canvas?) {        super.onDraw(canvas)        initWaveAnim()        drawWaterWave(canvas)        invalidate()    }    private fun initWaveAnim() {        Log.d("WaveAnim", " pauseAF start " + mIsPauseAfterStart + " lastAD " + mLastAnimDurating + " mDiff " + mDifferMills + "  : " + mLastAimIndex)        if (mIsPauseAfterStart) {            if (mLastAnimDurating <= mDifferMills) {                mLastAnimDurating += 17            }            if (mLastAnimDurating >= mDifferMills) {                var currentMills = SystemClock.elapsedRealtime() - mStartMills                if (currentMills >= mDifferMills && currentMills < mDifferMills + 50) {                    if (!mIsStartAnim) {                        controlStartAnim()                        mIsStartAnim = true                        Log.d("initWaveAnim", " start " + currentMills)                    }                } else if (currentMills >= mDifferMills * 2 && currentMills < mDifferMills * 2 + 50) {                    if (!mIsStartAnim1) {                        controlStartAnim()                        mIsStartAnim1 = true                        Log.d("initWaveAnim1", " start1 " + currentMills)                    }                } else if (currentMills >= mDifferMills * 3                        && currentMills < mDifferMills * 3 + 50) {                    if (!mIsStartAnim2) {                        controlStartAnim()                        mIsStartAnim2 = true                        Log.d("initWaveAnim2", " start2 " + currentMills)                    }                    mIsPauseAfterStart = false                }            }        }    }    private fun controlStartAnim() {        mTempLastAnimIndex ++        if (mTempLastAnimIndex > 2) {            mTempLastAnimIndex = 0        }        Log.d("controlStartAnim", " controlStartAnim " + mTempLastAnimIndex)        startIndexAnim(mTempLastAnimIndex)    }    private fun startIndexAnim(index: Int) {        if (index == 0) {            waterWaveAnimator()        } else if (index == 1) {            waterWaveAnimator1()        } else if (index == 2) {            waterWaveAnimator2()        }    }    fun pauseWaterWaveAnim() {        mIsPauseAfterStart = false        mIsPause = true        mPressPauseMills = SystemClock.elapsedRealtime()        Log.d("Pause", "1" + mIsPause)    }    fun startWaterWaveAnim() {        mIsStartAnim = false        mIsStartAnim1 = false        mIsStartAnim2 = false//        mIsReStartMills = false        mIsPause = false        mIsPauseAfterStart = true        mStartMills = SystemClock.elapsedRealtime()        if (mLastAimIndex != -1) {            mLastAnimDurating = getAnimCurrentDurating(mLastAimIndex)            mTempLastAnimIndex = mLastAimIndex        }    }    private fun drawWaterWave(canvas: Canvas?) {        if (mWaveValue > 0.01f) {            mWavePaint.alpha = (255 * (1 - mWaveValue)).toInt()            canvas?.drawCircle(mCenterX, mCenterY, mRadius + (mMaxRadius - mRadius) * mWaveValue, mWavePaint)        }        if (mWaveValue1 > 0.01f) {            mWavePaint1.alpha = (255 * (1 - mWaveValue1)).toInt()            canvas?.drawCircle(mCenterX, mCenterY, mRadius + (mMaxRadius - mRadius) * mWaveValue1, mWavePaint1)        }        if (mWaveValue2 > 0.01f) {            mWavePaint2.alpha = (255 * (1 - mWaveValue2)).toInt()            canvas?.drawCircle(mCenterX, mCenterY, mRadius + (mMaxRadius - mRadius) * mWaveValue2, mWavePaint2)        }    }    private fun initWaterWaveAnimator() {        mWaveAnim = ValueAnimator.ofFloat(1f)        mWaveAnim?.repeatCount = ValueAnimator.INFINITE        mWaveAnim?.interpolator = DecelerateInterpolator()        mWaveAnim?.setDuration(5 * 1000)        mWaveAnim?.addUpdateListener {            mWaveValue = it.animatedValue as Float        }        mWaveAnim?.addListener(object :AnimatorListenerAdapter() {            override fun onAnimationRepeat(animation: Animator?) {                super.onAnimationRepeat(animation)                mLastAimIndex = 0                if (mIsPause) {                    mWaveAnim?.cancel()                    Log.d("a0", " cancle")                }                if (mIsPauseAfterStart) {                    mWaveAnim?.cancel()                }            }            override fun onAnimationStart(animation: Animator?) {                super.onAnimationStart(animation)                mLastAimIndex = 0                Log.d("initWaveAnim1", " onStart")            }            override fun onAnimationEnd(animation: Animator?) {                super.onAnimationEnd(animation)                Log.d("a0", " onAnimationEnd")            }        })    }    private fun initWaterWaveAnimator1() {        mWaveAnim1 = ValueAnimator.ofFloat(1f)        mWaveAnim1?.repeatCount = ValueAnimator.INFINITE        mWaveAnim1?.interpolator = DecelerateInterpolator()        mWaveAnim1?.setDuration(5 * 1000)        mWaveAnim1?.addUpdateListener {            mWaveValue1 = it.animatedValue as Float        }        mWaveAnim1?.addListener(object :AnimatorListenerAdapter() {            override fun onAnimationRepeat(animation: Animator?) {                super.onAnimationRepeat(animation)                mLastAimIndex = 1                if (mIsPause) {                    mWaveAnim1?.cancel()                    Log.d("a1", " cancle")                }                if (mIsPauseAfterStart) {                    mWaveAnim1?.cancel()                }            }            override fun onAnimationStart(animation: Animator?) {                super.onAnimationStart(animation)                mLastAimIndex = 1                Log.d("initWaveAnim3", " onStart")            }            override fun onAnimationEnd(animation: Animator?) {                super.onAnimationEnd(animation)                Log.d("a1", " onAnimationEnd")            }        })    }    private fun initWaterWaveAnimator2() {        mWaveAnim2 = ValueAnimator.ofFloat(1f)        mWaveAnim2?.repeatCount = ValueAnimator.INFINITE        mWaveAnim2?.interpolator = DecelerateInterpolator()        mWaveAnim2?.setDuration(5 * 1000)        mWaveAnim2?.addUpdateListener {            mWaveValue2 = it.animatedValue as Float        }        mWaveAnim2?.addListener(object :AnimatorListenerAdapter() {            override fun onAnimationRepeat(animation: Animator?) {                super.onAnimationRepeat(animation)                mLastAimIndex = 2                if (mIsPause) {                    mWaveAnim2?.cancel()                }                if (mIsPauseAfterStart) {                    mWaveAnim2?.cancel()                }            }            override fun onAnimationStart(animation: Animator?) {                super.onAnimationStart(animation)                mLastAimIndex = 2                Log.d("initWaveAnim2", " onStart")            }            override fun onAnimationEnd(animation: Animator?) {                super.onAnimationEnd(animation)                Log.d("a2", " End2")            }        })    }    private fun getAnimCurrentDurating(index: Int):Int {        if (index == 0) {            return (mWaveValue * 1000f * 5).toInt()        } else if (index == 1) {            return (mWaveValue1 * 1000f * 5).toInt()        } else if (index == 2) {            return (mWaveValue2 * 1000f * 5).toInt()        }        return -1    }    private fun waterWaveAnimator() {        if (mWaveAnim != null && !mWaveAnim!!.isStarted) {            mWaveAnim?.start()        } else if (mWaveAnim != null && mWaveAnim!!.isStarted) {            mWaveAnim?.resume()        }    }    private fun waterWaveAnimator1() {        if (mWaveAnim1 != null && !mWaveAnim1!!.isStarted) {            mWaveAnim1?.start()        } else if (mWaveAnim1 != null && mWaveAnim1!!.isStarted) {            mWaveAnim1?.resume()        }    }    private fun waterWaveAnimator2() {        if (mWaveAnim2 != null && !mWaveAnim2!!.isStarted) {            mWaveAnim2?.start()        } else if (mWaveAnim2 != null && mWaveAnim2!!.isStarted) {            mWaveAnim2?.resume()        }    }//    override fun onTouchEvent(event: MotionEvent?): Boolean {////        if (event?.action == MotionEvent.ACTION_DOWN) {//            if (!mA) {//                pauseWaterWaveAnim()//            } else {//                startWaterWaveAnim()//            }//            mA = !mA//        }//        return true//    }}